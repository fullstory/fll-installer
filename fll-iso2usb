#!/bin/bash
#
# Copyright (C) 2007 Joaquim Boura <x-un-i@sidux.com>
#           (C) 2007 Kel Modderman <kel@otaku42.de>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this package; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
# On Debian GNU/Linux systems, the text of the GPL license can be
# found in /usr/share/common-licenses/GPL.
#-------------------------------------------------------------------
#
# given an usb pen, eg /dev/sdb, /dev/sdc we create ** one **  partiton on that 
# device make it bootable, format it with ext3
# install grub into it
# copy the message file into the grub dirs
# create directory for iso, kernel, initrd (eg sidux)
# copy the files into there.
# create the menu.lst file on it
#

#--------------------------------------------------------------
# source distro-defaults
#--------------------------------------------------------------
if [ -s /etc/default/distro ]; then
	. /etc/default/distro
else
	echo "E: requires distro-defaults"
	exit 1
fi

#--------------------------------------------------------------
# functions
#--------------------------------------------------------------
usage()
{
	echo ""
	echo "Create an fromiso (frugal) installation on a USB drive"
	echo ""
	echo "-d|--debug                debug sh code execution"
	echo "-D|--drive </dev/sdX>     name of device where to install the \"fromiso\""
	echo "-h|--help                 print this help"
	echo "-I|--iso   <iso_file>     iso file name to be installed"
	echo "-t|--test                 copy everything but do not copy the iso"
	echo ""
	echo "Everything after -- will be appended to the kernel cmdline of grub menu.lst"
	echo ""
	echo "Use it at your own risk, it comes without any warranty."
	echo ""
}
#--------------------------------------------------------------
error()
{
	local exitval="${1}"
	shift

	# the gui currently uses this
	echo "${exitval}-${@}" > /tmp/.fll-iso2usb
	
	echo "E: ${@}"
}
#--------------------------------------------------------------
say()
{
	echo "O: ${1}"
}
#--------------------------------------------------------------
valid_label()
{
	# label may contain only these characters
	case "${1}" in
		*[!A-Za-z0-9-_]*)
			return 1
			;;
	esac
	
	return 0
}
#--------------------------------------------------------------
refresh_block_devices()
{
	if which udevadm >/dev/null; then
		udevadm trigger --subsystem-match=block
		udevadm settle --timeout=30
	elif which udevtrigger >/dev/null; then
		udevtrigger --subsystem-match=block
		udevsettle --timeout=30
	fi
}
#--------------------------------------------------------------
prepare_partition()
{
	local device="${1}"
	local partition="${2}"
	local label="${3:-${FLL_DISTRO_NAME}USB}"
	shift 3

	local ev
	local is_bootable part_id

	say "preparing bootable partition on device: ${device}"

	# clear the partition table
	dd if=/dev/zero of=${device} bs=1M count=16

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to zero ${device}"
		return 1
	fi
	
	# create partition
	fdisk "${device}" \
<<EOF

n
p
1


t
83
a
1
p
w
EOF
	
	ev="${?}"
	if [ "${ev}" -ne 0 ] || [ ! -b "${partition}" ]; then
		error "${ev}" "failed to create partition on device: ${device}"
		return 1
	fi
	
	refresh_block_devices

	is_bootable=$(LC_ALL=C fdisk -l ${device} | awk -v part=${partition} '
		{
			if($1 == part && $2 == "*") {
				print 1
				exit
			}
		}
	')

	if [ "${is_bootable}" -ne 1 ]; then
		# set boot flag
		fdisk "${device}" \
<<EOF
a
1
p
w
EOF

		ev="${?}"
		if [ "${ev}" -ne 0 ]; then
			error "${ev}" "fdisk stuffed up while setting device as bootable"
			return 1
		fi
	
		refresh_block_devices

		is_bootable=$(LC_ALL=C fdisk -l ${device} | awk -v part=${partition} '
			{
				if($1 == part && $2 == "*") {
					print 1
					exit
				}
			}
		')

		if [ "${is_bootable}" -ne 1 ]; then
			error 1 "could not make USB device bootable"
			return 1
		fi
	fi

	part_id=$(LC_ALL=C fdisk -l ${device}  | awk -v part=${partition} '
		{
			if($1 == part && $6 == 83) {
				print $6
				exit
			}
		}
	')
	
	if [ "${part_id}" -ne 83 ]; then
		# set partition type
		fdisk "${device}" \
<<EOF
t
83
p
w
EOF
		
		ev="${?}"
		if [ "${ev}" -ne 0 ]; then
			error "${ev}" "fdisk failed when setting partition type"
			return 1
		fi
		
		refresh_block_devices

		part_id=$(LC_ALL=C fdisk -l ${device}  | awk -v part=${partition} '
			{
				if($1 == part && $6 == 83) {
					print $6
					exit
				}
			}
		')

		if [ "${part_id}" -ne 83 ]; then
			error 1 "failed to set partition type 83 on ${device}"
			return 1
		fi	
	fi	

	mkfs.ext3 -q -m 1 -L "${label}" "${partition}"
	
	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to format ${partition}"
		return 1
	fi

	say "prepared bootable partition: ${partition} label: ${label}"
}
#--------------------------------------------------------------
mount_partition()
{
	local partition="${1}"
	local mountpoint="${2}"
	shift 2

	local ev

	say "mounting ${partition} on ${mountpoint}"

	mount -o rw "${partition}" "${mountpoint}"

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to mount ${partition} on ${mountpoint}"
		return 1
	fi

	say "mount point ready: ${mountpoint}"
}
#--------------------------------------------------------------
umount_partition()
{
	local partition="${1}"
	local mountpoint="${2}"
	shift 2

	local ev

	say "umounting ${partition} from ${mountpoint}"

	umount "${partition}"

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to umount ${partition} from ${mountpoint}"
		return 1
	fi

	rmdir "${mountpoint}"

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to remove mount point: ${mountpoint}"
		return 1
	fi

	say "mount point destroyed: ${mountpoint}"
}
#--------------------------------------------------------------
install_grub()
{
	local device="${1}"
	local mountpoint="${2}"
	shift 2
	
	local ev
	local device_map disk

	say "installing grub on ${device}"

	grub-install --recheck --no-floppy --root-directory="${mountpoint}" "${device}"

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "grub-install failed, root-directory=${mountpoint}, device=${device}"
		return 1
	fi

	device_map="${mountpoint}/boot/grub/device.map"
	disk=$(echo ${device} |cut -d '/' -f 3)

	old_hdmap=$(grep ${disk} ${device_map}| awk '{print $1}' | sed -e "s/[\(,\)]//g")

	# fix the device.map file
	sed -i -e "s|(hd0)|(hdX)|" -e "s|(${old_hdmap})|(hd0)|" \
		-e "s|(hdX)|(${old_hdmap})|" "${device_map}"
	
	say "grub successfully installed to ${device}"
}
#--------------------------------------------------------------
copy_files_from_dev()
{
	local name="${1}"
	local mountpoint="${2}"
	local nocopy="${3}"
	shift 3
	
	local ev
	local booted_device fll_booted_dir
	
	FLL_BASE_DIR_AWK=$(echo $FLL_BASE_DIR | sed -e 's|\/|\\\/|g')
	booted_device=$(LC_ALL=C mount | awk '
		{
			if(/iso9660/ && /'${FLL_BASE_DIR_AWK}'/ && /\/dev\//)
				print $1
		}
	')
	fll_booted_dir=$(LC_ALL=C mount | awk '
		{
			if(/iso9660/ && /'${FLL_BASE_DIR_AWK}'/ && /\/dev\//)
				print $3
		}
	')

	say "copying files to ${mountpoint}"
	
	cp -v	${fll_booted_dir}/boot/message \
		${fll_booted_dir}/boot/initrd* \
		${fll_booted_dir}/boot/vmlinuz* \
		${fll_booted_dir}/boot/memtest86+.bin \
			${mountpoint}/boot
	
	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to copy files to ${mountpoint}/boot"
		return 1
	fi

	if [ "${nocopy}" = "yes" ]; then
 		return 0
	fi

	dd if="${booted_device}" of="${mountpoint}/${name}"

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "dd failed to clone ${booted_device} to ${mountpoint}/${name}"
		return 1
	fi

	say "files successfully copied to ${mountpoint}"
}
#--------------------------------------------------------------
copy_files_from_local_iso()
{
	local iso="${1}"
	local name="${2}"
	local mountpoint="${3}"
	local nocopy="${4}"
	shift 4

	local ev
	local mounted_iso 
	
	say "mounting iso: ${iso}"
	
	mounted_iso="$(mktemp -d -p /tmp/ install-usb-iso.XXXXX)"

	while :; do
		if mount -t iso9660 -o loop,ro "${iso}" "${mounted_iso}"; then
			break
		elif [[ -b ${iso} ]]; then
			echo
			echo "Please load iso media into ${iso#/dev/} tray."
			echo "Press Enter to continue or Ctrl+c to cancel."
			echo
			read x
			continue
		fi
	done

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to mount ${iso} on ${mounted_iso}"
		return 1
	fi

	say "iso mounted on ${mounted_iso}"
	say "copying files to ${mountpoint}"
	
	cp -v	${mounted_iso}/boot/message \
		${mounted_iso}/boot/initrd* \
		${mounted_iso}/boot/vmlinuz* \
		${mounted_iso}/boot/memtest86+.bin \
			${mountpoint}/boot
	
	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to copy files to ${mountpoint}/boot"
		return 1
	fi

	umount ${mounted_iso}

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to umount ${mounted_iso}"
		return 1
	fi

	rmdir ${mounted_iso}

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to remove ${mounted_iso}"
		return 1
	fi

	if [ "${nocopy}" = "yes" ]; then
 		return 0
	fi

	cp -v "${iso}" "${mountpoint}/${name}"

	ev="${?}"
	if [ "${ev}" -ne 0 ]; then
		error "${ev}" "failed to cp ${iso} to ${mountpoint}/${name}"
		return 1
	fi

	say "files successfully copied to ${mountpoint}"
}
#--------------------------------------------------------------

#--------------------------------------------------------------
menulst()
{
	local partition="${1}"
	local mountpoint="${2}"
	local name="${3}"
	shift 3

	local ev
	local initrd vmlinuz uuid

	say "creating ${mountpoint}/boot/grub/menu.lst"

	# if more than one kernel on &{mountpoint}/boot then we have multiarch
	kernels=$(find ${mountpoint}/boot/ -maxdepth 1 -type f -name 'vmlinuz-*' -printf '%P\n' | sed -n 's/^vmlinuz-//p')
	uuid=$(blkid -o value -s UUID ${partition})

	cat > ${mountpoint}/boot/grub/menu.lst \
<<EOF
default 0
timeout 10
color red/black light-red/black
foreground EE0000
background 400000
gfxmenu /boot/message

EOF

	for kernel in ${kernels}; do
	cat >> ${mountpoint}/boot/grub/menu.lst \
<<EOF
##ISO boot
title ${name} (USB) ${kernel}
kernel (hd0,0)/boot/vmlinuz-${kernel} boot=fll fromhd=UUID=${uuid} fromiso nointro quiet vga=791 ${@}
initrd (hd0,0)/boot/initrd.img-${kernel}

title memtest86+
kernel /boot/memtest86+.bin

EOF

done
}

#--------------------------------------------------------------
# preparation, process cli arguments with getopt
#--------------------------------------------------------------
TEMP=$(getopt -o dD:I:hL:pt \
        --long debug,drive:,iso:,help,label:,test \
        -n  "$(basename ${0})" -- "${@}")

if [ "${?}" -ne 0 ]; then
	error 255 "getopt terminated abnormally"
	exit 255
fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "${TEMP}"

while true ; do
	case "${1}" in
		-d|--debug)
			set -x
			shift
			;;
		-D|--drive)
			DEVICE="${2}"
			shift 2
			;;
		-I|--iso)
			ISO="${2}"
			shift 2
			;;
		-h|--help)
			usage
			exit 0
			;;
		-L|--label)
			valid_label "${2}" && LABEL="${2}"
			shift 2
			;;
		-t|--test)
			NOCOPY="yes"
			shift
			;;
		--)
			shift
			break
			;;
		*)
			error 255 "getopt internal error"
			exit 255
			;;
	esac
done

#--------------------------------------------------------------
# sanity checking and argument post-processing
#--------------------------------------------------------------
if [ -z "${DEVICE}" ]; then 
	error 2 "requires -D|--drive option"
	exit 2
fi

if [ ! -b "${DEVICE}" ]; then 
	error 3 "device not found: ${DEVICE}"
	exit 3
fi

if [ -z "${ISO}" ] && [ "${FLL_DISTRO_MODE}" = "live" ] && \
	FLL_BASE_DIR=$(dirname ${FLL_MOUNTPOINT})
	grep -s -q -w fromiso /proc/cmdline; then
	# system booted fromiso, reuse the iso
	ISO_T=$(grep -E -o 'fromiso=[^[:space:]]+' /proc/cmdline | sed 's/^fromiso=//')
	# don't waste heaps of time for this, maxdepth of 3 for custom dir
	if [ "${ISO_T}" ]; then
		ISO=$(find ${FLL_BASE_DIR} -maxdepth 3 -type f -print0 | grep -FzZ ${ISO_T})
	else
		ISO=$(find ${FLL_BASE_DIR} -maxdepth 2 -type f -name ${FLL_MEDIA_NAME})
	fi
fi	

if [ "${FLL_DISTRO_MODE}" = "installed" ] || \
	grep -s -q -w toram /proc/cmdline; then
	# installed system or system booted with "toram"
	# must supply iso media
	if [ -z "${ISO}" ] || [ ! -r "${ISO}" ]; then
		error 4 "host/toram mode requires -I|--iso option"
		exit 4
	fi
	FORCE_LOCAL_ISO="1"
fi

#--------------------------------------------------------------
# main()
#--------------------------------------------------------------
PARTITION="${DEVICE}1"
USBTMPDIR="$(mktemp -d -p /tmp/ install-usb.XXXXX)"

prepare_partition "${DEVICE}" "${PARTITION}" "${LABEL}"		|| exit 5

mount_partition "${PARTITION}" "${USBTMPDIR}"			|| exit 6

trap "{ [[ -d ${USBTMPDIR} ]] && umount_partition ${PARTITION} ${USBTMPDIR}; }" exit

install_grub "${DEVICE}" "${USBTMPDIR}"				|| exit 7

if [ "${FORCE_LOCAL_ISO}" ]; then
	copy_files_from_local_iso "${ISO}" \
		"${FLL_MEDIA_NAME}" "${USBTMPDIR}" "${NOCOPY}"	|| exit 8
else
	copy_files_from_dev \
		"${FLL_MEDIA_NAME}" "${USBTMPDIR}" "${NOCOPY}"	|| exit 9
fi

menulst "${PARTITION}" "${USBTMPDIR}" "${FLL_DISTRO_NAME}" ${@}	|| exit 10

exit 0
