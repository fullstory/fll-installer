##
##-------------------------------------
# Needs:
# HD_CHOICE
# BOOT_WHERE (also changed here)
# TARGET_MNT_POINT
# FLL_DISTRO_NAME
# HD_FSTYPE 
# BOOT_RUNNING_KERNEL
# TMPDIR
# LANG
# HD_MAP
#
# Calls:
# logit
# get_root_device
# chroot_it
# translate_linux_to_grub
# get_grub_cmdline
# getbootparam
#
# update_status
# install_grub
#
##-------------------------------------
##
#-----------------
# 
# ???????? device_map ????????
#------------------
install_grub()
{
	local GRUB_MBR
	local GRUB_CMDLINE
	local GROOT
	local SCSI
	local GRUB_DEFVGA
	local GRUB_VGA
	local root_partition
	local root_device
	local device
	local usb_dev
	local bootpart
	local point
	
	#
	# log my call
	#
	logit $"install_grub"
	#

	root_partition=$(echo ${HD_CHOICE} |cut -d"'" -f2)

	root_device=$(get_root_device $root_partition)

	device=$(echo $root_device|cut -d / -f3)
	
	usb_dev=$(echo $(readlink -f /sys/block/${device}/device) | grep  "usb")

	if [ -n "${usb_dev}" ]; then
		# USB install must have first Grub on partition
		BOOT_WHERE="partition"
	else
		# in case of jfs/xfs force installation to mbr
		# but only if HD is not on USB

		case $HD_FSTYPE in
		jfs|xfs) BOOT_WHERE="mbr";;
		esac
	fi

	#
	# create device.map
	#
	grub-install --recheck --no-floppy --root-directory=$TARGET_MNT_POINT \
		/dev/null &>/dev/null
	[ $? -ne 0 ] && grub-install --recheck --no-floppy \
			--root-directory=$TARGET_MNT_POINT /dev/null &>/dev/null

	#
	# ?? IS this export needeed ??
	#
	export device_map=$TARGET_MNT_POINT/boot/grub/device.map
	#
	# ?? IS this export needeed ??
	#

	if [ "$BOOT_WHERE" = "mbr" ]
	then
		GRUB_MBR=$(grep "(hd0)" $TARGET_MNT_POINT/boot/grub/device.map | awk '{ print $2 }')
		[ -z "$GRUB_MBR" ] && return 1
		# Make a backup of the old mbr
		dd if=$GRUB_MBR of=$TARGET_MNT_POINT/boot/${FLL_DISTRO_NAME}-old-mbr.$(date -I) \
			bs=512 count=1 >/dev/null 2>/dev/null
	fi

	# 
	# Create initital menu.lst
	#
	(cd $TARGET_MNT_POINT/boot; ln -sf initrd.img-$BOOT_RUNNING_KERNEL initrd.img)
	chroot_it update-grub -y >/dev/null 2>/dev/null

	# change menu.lst
	# TODO other languages
	# Add german keybindings 
	case "$LANG" in
		de*|at*|ch*)
			cp -f $TARGET_MNT_POINT/boot/grub/menu.lst $TMPDIR/menu.lst
			cat > $TARGET_MNT_POINT/boot/grub/menu.lst << EOF
# Deutsche Tastaturbelegung
setkey y z
setkey z y
setkey Y Z
setkey Z Y
setkey equal parenright
setkey parenright parenleft
setkey parenleft asterisk
setkey doublequote at
setkey plus bracketright
setkey minus slash
setkey slash ampersand
setkey ampersand percent
setkey percent caret
setkey underscore question
setkey question underscore
setkey semicolon less
setkey less numbersign
setkey numbersign backslash
setkey colon greater
setkey greater bar
setkey asterisk braceright
EOF
	cat $TMPDIR/menu.lst >> $TARGET_MNT_POINT/boot/grub/menu.lst
		;;
	esac

	# no alternatives please
	perl -pi -e 's/^# alternative=true/# alternative=false/g' \
		$TARGET_MNT_POINT/boot/grub/menu.lst
	#
	# save the default setting
	perl -pi -e 's/^default .*/default saved/g' $TARGET_MNT_POINT/boot/grub/menu.lst

	# #
	# # should i understand this???
	# #
	# add graphical menu
	# if there is a "/boot" mounted then this is grub root
	# otherwise we have /boot over the / partition
	bootpart=
	for i in $HD_MAP; do
		point=$(echo $i | cut -d":" -f2)
		if [ "$point" = "/boot" ]; then
			bootpart=$(echo $i | cut -d":" -f1)
            break
		fi
	done

	#
	# bad handle boot partition
	#
	if [ -n "$bootpart" ]; then
		GROOT=$(translate_linux_to_grub $bootpart)
	else
		#
		# ?? IS this export needeed ??
		#
		export device_map=$TARGET_MNT_POINT/boot/grub/device.map
		export kernel_vers=$(uname -r)
		#
		# ?? IS this export needeed ??
		#
		root_device=$(grep "^kernel.*${kernel_ver}.*root=" \
			$TARGET_MNT_POINT/boot/grub/menu.lst |\
			grep -v "single" |\
			sed 's#^kernel.*root=##'|sed 's# .*$##')

		GROOT=$(translate_linux_to_grub $root_device)
	fi

	if [ -n "$GROOT" -a -s $TARGET_MNT_POINT/boot/message ]; then
		if { mount | grep -q $TARGET_MNT_POINT/boot ; }; then
			perl -pi -e "s|^color (.*)|color \1\ngfxmenu $GROOT/message|g" \
				$TARGET_MNT_POINT/boot/grub/menu.lst
		else
			perl -pi -e "s|^color (.*)|color \1\ngfxmenu $GROOT/boot/message|g" \
				$TARGET_MNT_POINT/boot/grub/menu.lst
		fi
	fi

	perl -pi -e "s|^root.*$|root\t\t${GROOT}|" \
		$TARGET_MNT_POINT/boot/grub/menu.lst
	perl -pi -e "s|^# groot=.*$|# groot=${GROOT}|" \
		$TARGET_MNT_POINT/boot/grub/menu.lst

	#
	# Create a new cmdline
	#
	
	GRUB_CMDLINE=$(get_grub_cmdline)
	
	# Fallback :-)
	if [ -z "$GRUB_CMDLINE" ]
	then
		SCSI=$(cat /proc/cmdline | tr ' ' '\n' | grep =scsi |  tr '\n' ' ')
		GRUB_CMDLINE="ramdisk_size=100000 apm=power-off nomce ${SCSI}"
	fi

	# extract vga mode from CMDLINE
	GRUB_DEFVGA="791"
	GRUB_VGA=$(getbootparam vga)
	[ -z "$GRUB_VGA" ] && GRUB_VGA="$GRUB_DEFVGA"

	GRUB_CMDLINE="$GRUB_CMDLINE vga=$GRUB_VGA"

	#
	# correct the kopt grub variable
	#
	perl -pi -e "s|^# kopt=root=(.*) ro|# kopt=root=\1 ro $GRUB_CMDLINE|g" \
		$TARGET_MNT_POINT/boot/grub/menu.lst
	perl -pi -e "s|^kernel(.*) ro|kernel\1 ro $GRUB_CMDLINE|g" \
		$TARGET_MNT_POINT/boot/grub/menu.lst

	#
	# ?? IS this export needeed ??
	#
	export device_map=$TARGET_MNT_POINT/boot/grub/device.map
	#
	# ?? IS this needeed ??
	#

	# hook update-grub -y into the kernel installing chain
cat << EOF > "$TARGET_MNT_POINT/etc/kernel-img.conf"
# Kernel Image management overrides
# See kernel-img.conf(5) for details
do_symlinks = Yes
postinst_hook = /usr/sbin/update-grub
postrm_hook = /usr/sbin/update-grub
do_bootloader = no
do_initrd = Yes
relative_links = Yes
EOF
	#
	# install grub
	#
	case $BOOT_WHERE in
		partition)
			grub-install --root-directory=$TARGET_MNT_POINT "$HD_CHOICE" \
				>/dev/null 2>/dev/null || \
				grub-install --root-directory=$TARGET_MNT_POINT "$HD_CHOICE" \
					>/dev/null 2>/dev/null
			;;
		mbr)
			grub-install --root-directory=$TARGET_MNT_POINT "(hd0)" >/dev/null 2>/dev/null
			;;
	esac

	return 0
}

